Governance Graph Processor (GGP)
Canonical Data Model – Dual Persistence (PostgreSQL + MongoDB)
1. Purpose
This document defines the authoritative data model for the Governance Graph Processor (GGP) MVP.
It formally establishes:
PostgreSQL as the system of record (transactional, authoritative, auditable)
MongoDB as the read-optimized persistence layer for frontend integration
A CQRS-style separation between write models and read models
2. Design Principles
Single Write Authority
All writes occur in PostgreSQL only
MongoDB never accepts direct writes from the application layer
Read Model Optimization
MongoDB stores denormalized, pre-joined documents
Optimized specifically for React frontend screens
Audit-First Architecture
Every mutation produces an immutable audit event
No destructive updates
Eventual Consistency (Explicit)
MongoDB is eventually consistent with PostgreSQL
FE accepts slight lag for simplicity and performance
3. PostgreSQL — Canonical Write Model
3.1 executions
Represents a single governance execution lifecycle.
executions (
  execution_id UUID PRIMARY KEY,
  trigger_type TEXT,
  initiated_by TEXT,
  initiated_at TIMESTAMP,
  status TEXT,
  summary TEXT
)
Indexes:
execution_id (PK)
initiated_at
3.2 components
Canonical registry of governance components.
components (
  component_id UUID PRIMARY KEY,
  component_name TEXT,
  component_type TEXT,
  current_version TEXT,
  created_at TIMESTAMP
)
3.3 component_changes
Records component deltas per execution.
component_changes (
  change_id UUID PRIMARY KEY,
  execution_id UUID REFERENCES executions(execution_id),
  component_id UUID REFERENCES components(component_id),
  previous_version TEXT,
  new_version TEXT,
  change_type TEXT,
  materiality TEXT,
  rationale TEXT
)
Indexes:
execution_id
component_id
3.4 sop_versions
Versioned SOP artifacts generated by GGP.
sop_versions (
  sop_version_id UUID PRIMARY KEY,
  sop_id UUID,
  execution_id UUID REFERENCES executions(execution_id),
  version TEXT,
  change_type TEXT,
  approval_status TEXT,
  published_at TIMESTAMP
)
Indexes:
sop_id
execution_id
3.5 dependencies
Directed dependency graph between components and SOPs.
dependencies (
  dependency_id UUID PRIMARY KEY,
  source_id UUID,
  target_id UUID,
  dependency_type TEXT
)
4. MongoDB — Read Models (Frontend Optimized)
MongoDB collections are materialized views derived from PostgreSQL.
4.1 execution_audit_view
Used by Execution Audit Trail screen.
{
  "execution_id": "uuid",
  "trigger_type": "manual | automated",
  "initiated_by": "role / user",
  "initiated_at": "timestamp",
  "summary": "string",
  "component_changes": [
    {
      "component_id": "uuid",
      "component_name": "string",
      "previous_version": "x.y.z",
      "new_version": "x.y.z",
      "change_type": "major | minor | patch",
      "materiality": "low | medium | high",
      "rationale": "string"
    }
  ],
  "sop_updates": [
    {
      "sop_id": "uuid",
      "version": "x.y.z",
      "change_type": "major | minor | patch",
      "approval_status": "approved | pending",
      "published_at": "timestamp"
    }
  ]
}
Indexes:
execution_id
initiated_at
4.2 sop_history_view
Used by SOP Version History Viewer.
{
  "sop_id": "uuid",
  "sop_name": "string",
  "versions": [
    {
      "version": "x.y.z",
      "change_type": "major | minor | patch",
      "approval_status": "approved | pending",
      "published_at": "timestamp",
      "execution_id": "uuid"
    }
  ]
}
Indexes:
sop_id
5. Sync Strategy (Postgres → Mongo)
5.1 Outbox Pattern (Recommended)
PostgreSQL writes emit outbox events
Worker consumes outbox events
Worker materializes / updates Mongo read models
Example outbox payload:
{
  "event_type": "EXECUTION_COMPLETED",
  "execution_id": "uuid",
  "occurred_at": "timestamp"
}
6. Consistency & Invariants
PostgreSQL is always authoritative
MongoDB documents can be rebuilt at any time
No FE writes bypass Postgres
Audit logs are append-only
Version history is immutable
7. Frontend Access Pattern
React frontend:
Reads only from MongoDB-backed APIs
Never queries PostgreSQL directly
Receives fully shaped JSON documents
8. MVP Constraints
Included:
Execution audit trail read model
SOP version history read model
Eventual consistency
Excluded:
Bi-directional sync
Real-time streaming guarantees
FE-side write actions
9. Future Evolution
Add Redis for hot execution caching
CDC-based sync (Debezium) if scale demands
Graph DB for dependency traversal (optional)
10. Kafka Integration (Event Backbone)
Kafka is the event distribution layer for NSDC engines. It is used for:
Engine-to-engine signaling (decoupled integration)
Read-model projection into MongoDB
Durable event history and replay
Asynchronous workflows (approvals, notifications, long-running processes)
Kafka is not the system of record.
11. Postgres Outbox (Authoritative Event Emission)
To guarantee reliable event publication, GGP uses the Outbox Pattern:
Write canonical data to Postgres
Insert an outbox event row in the same transaction
A publisher service reads outbox rows and publishes to Kafka
11.1 outbox_events (Postgres)
outbox_events (
  outbox_id UUID PRIMARY KEY,
  aggregate_type TEXT,           -- e.g., "execution", "sop"
  aggregate_id UUID,             -- e.g., execution_id, sop_id
  event_type TEXT,               -- e.g., ggp.execution.completed
  event_version INT,
  payload JSONB,
  occurred_at TIMESTAMP,
  published_at TIMESTAMP NULL,
  publish_attempts INT DEFAULT 0,
  last_error TEXT NULL
)
Indexes:
published_at (polling)
aggregate_id (traceability)
12. Kafka Topic Topology (MVP)
Start with a minimal set of topics that supports GGP read-model projection and future engine growth.
12.1 Core GGP Topics
ggp.execution.created
ggp.execution.completed
ggp.sop.versioned
12.2 Cross-Engine Topics (Early Defaults)
dat.order.executed
flo.ledger.entry.posted
sig.signal.detected
Partitioning keys:
GGP topics: key by execution_id
SOP topics: key by sop_id
DAT topics: key by order_id
FLO topics: key by ledger_entry_id (or entity_id)
SIG topics: key by signal_type or market_id
13. Event Envelope Standard
All emitted events MUST use a consistent envelope for traceability, idempotency, and schema evolution.
{
  "event_id": "uuid",
  "event_type": "ggp.execution.completed",
  "event_version": 1,
  "occurred_at": "2025-12-16T23:12:34Z",
  "producer": "GGP",
  "correlation_id": "uuid",
  "idempotency_key": "uuid-or-hash",
  "payload": {}
}
Rules:
Events are immutable
Breaking schema changes increment event_version
Consumers must be idempotent using event_id or idempotency_key
14. Updated Sync Strategy (Kafka-Native)
14.1 Authoritative Write Path
GGP writes canonical rows to Postgres
Same transaction inserts outbox_events
14.2 Publication
Outbox Publisher reads unpublished outbox rows
Publisher emits events to Kafka
Publisher marks published_at
14.3 Mongo Read Model Projection
Mongo Projector (Kafka consumer) consumes GGP topics
Projector builds/updates Mongo collections:
execution_audit_view
sop_history_view
15. Read Model Projection Rules (Mongo)
15.1 execution_audit_view Projector
Consumes:
ggp.execution.created
ggp.execution.completed
ggp.sop.versioned
Behavior:
On execution.created: create base document
On execution.completed: attach component_changes and execution summary
On sop.versioned: append to sop_updates
15.2 sop_history_view Projector
Consumes:
ggp.sop.versioned
Behavior:
Upsert SOP doc by sop_id
Append version records (immutable)
16. Frontend Access Pattern (Unchanged)
React frontend:
Reads only from Mongo-backed APIs
Never queries PostgreSQL directly
Receives fully shaped JSON documents
API endpoints:
GET /api/executions/{execution_id} → returns Mongo execution_audit_view
GET /api/sops/{sop_id}/versions → returns Mongo sop_history_view
17. Operational Notes (PowerEdge)
Kafka should run in KRaft mode (no ZooKeeper) for simplicity
Enable log retention long enough to support Mongo read-model rebuilds
Maintain consumer group offsets for projectors
Provide an administrative rebuild command: re-consume topics from earliest and rebuild Mongo
Recommended operational baselines:
Enable metrics collection for Kafka brokers and consumers
Set up log rotation and disk monitoring (Kafka is disk-heavy)
Back up Postgres regularly; Mongo read models are rebuildable
18. Service Topology (MVP Deployment)
This section enumerates the minimal set of services required to support a Kafka-native GGP MVP.
18.1 Required Services
PostgreSQL (System of Record)
Stores canonical write models (executions, components, component_changes, sop_versions, dependencies)
Stores outbox_events
Kafka Broker(s) (Event Backbone)
Durable transport and replay log for all engine events
MongoDB (Read Model Store)
Stores denormalized read models for frontend performance
GGP Write API (Backend)
Receives triggers / updates
Executes UDP + versioning workflow
Writes canonical records + inserts outbox events (transactional)
Outbox Publisher (Worker)
Polls Postgres outbox_events for unpublished rows
Publishes events to Kafka
Marks published rows (sets published_at, increments attempts)
Mongo Projector (Consumer)
Subscribes to Kafka topics
Builds/updates Mongo collections (execution_audit_view, sop_history_view)
Uses idempotency keys / event_id to avoid duplicates
Read API (Frontend Backend-for-Frontend)
Serves React screens using Mongo read models
Enforces role-based access (read-only MVP)
18.2 Optional Services (Recommended Soon)
Kafka UI (admin visibility)
Schema Registry (later, when event schemas evolve materially)
Redis (rate limiting + caching + job queue for non-Kafka tasks)
19. Rebuild Procedure (Mongo Read Models)
MongoDB read models are rebuildable and should be treated as disposable projections.
19.1 When to Rebuild
Mongo corruption or drift
Schema changes in read models
New projector logic
Validation / audit replays
19.2 Rebuild Invariants
Postgres remains authoritative
Kafka retains events long enough to rebuild from earliest offsets
Projectors must be idempotent
19.3 Recommended Rebuild Steps
Pause Projectors
Stop projector service(s) cleanly
Drop or Archive Mongo Read Collections
Drop: execution_audit_view, sop_history_view (or rename for archival)
Reset Consumer Group Offsets
Use a dedicated projector consumer group, e.g. mongo-projector-v1
Reset offsets to earliest for required topics
Restart Projectors
Projectors consume from earliest and rebuild collections
Validate
Pick a known execution_id and confirm:
execution document exists
component_changes populated
sop_updates consistent
Pick a known sop_id and confirm version history matches Postgres
19.4 Safety Notes
Avoid rebuilding during heavy write activity unless you can tolerate eventual consistency lag
Maintain a simple admin endpoint or CLI command that:
stops projectors
resets offsets
restarts projectors
20. Retention, DLQ, and Contract Hardening
This section defines operational hardening defaults for Kafka usage in the GGP MVP.
20.1 Topic Retention Targets (Recommended Defaults)
Retention should be long enough to:
Rebuild Mongo read models
Support audit replay and debugging
Suggested starting targets (adjust to disk constraints):
GGP Core Topics
ggp.execution.created → 14 days
ggp.execution.completed → 30 days
ggp.sop.versioned → 90 days (SOP history is high-value for traceability)
Cross-Engine Topics (Early Defaults)
dat.order.executed → 30 days
flo.ledger.entry.posted → 90 days
sig.signal.detected → 7–14 days (signals can be high-volume)
Note: If disk allows, extending retention is always helpful for replay.
20.2 DLQ Strategy (Dead Letter Topics)
A DLQ isolates poison messages and projector failures without blocking the entire consumer group.
Create dedicated DLQ topics:
dlq.ggp.execution
dlq.ggp.sop
dlq.dat.order
dlq.flo.ledger
dlq.sig.signal
When to send to DLQ:
JSON parsing errors
Missing required fields
Schema version mismatch where no compatible handler exists
Idempotency conflicts that cannot be resolved automatically
Mongo write failures after N retries
DLQ payload should include:
Original event envelope
Error type + message
Retry count
Timestamp
Consumer group
20.3 Producer / Consumer Contract
This contract governs how events are produced and consumed for correctness.
20.3.1 Idempotency Rules
Every event MUST include event_id and idempotency_key.
Consumers MUST persist a "seen" record (or maintain a compacted topic) to avoid duplicate application.
Projectors SHOULD treat duplicate events as a no-op.
Recommended consumer idempotency storage (choose one):
Mongo: processed_events collection keyed by event_id
Postgres: consumer_offsets + processed_events table
Kafka compacted topic: processed-events keyed by event_id
20.3.2 Ordering Rules
Kafka ordering is only guaranteed within a partition.
Use partition key = execution_id for execution lifecycle events.
Use partition key = sop_id for SOP version events.
Consumers must not assume ordering between unrelated aggregates.
20.3.3 Schema Evolution Rules
Envelope fields are stable.
Payload changes require versioned schema:
Non-breaking additions → keep event_version
Breaking changes → increment event_version
Consumers must support at least the previous version during migration.
20.3.4 Delivery Guarantees
Outbox Publisher provides at-least-once delivery.
Consumers must be idempotent to handle duplicates.
20.4 Retry Policy (Projectors)
Projectors should implement bounded retries before DLQ:
Retry on transient failures (network, Mongo timeouts)
Backoff strategy (exponential with jitter)
Max retries: 5 (default)
After max retries, emit to DLQ and continue consuming.
20.5 Replay Policy
For rebuilds and backfills:
Projector consumer group should be explicitly versioned, e.g. mongo-projector-v1
A new projector version gets a new group: mongo-projector-v2
Use earliest offsets for rebuilds
20.6 Observability Checklist (Minimum)
Track these metrics at minimum:
Outbox Publisher
outbox backlog (unpublished rows)
publish success/fail count
publish latency
Kafka
broker disk usage
consumer lag (per group/topic)
Projectors
projection success/fail count
DLQ count
idempotency duplicate count
End of Document
